// Copyright 2023 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

type DbgCommand {
	case Run;      // Begin program
	case Continue; // Continue program
	case Step;     // Step program until it reaches a different source line
	case Stepi;    // Step one instruction exactly
	case Next;     // Step program, jumping over calls
	case Nexti;    // Step one instruction, jumping over calls
	case Info(info: Info);   // Show breakpoints: "break" or locals: "local"
	case Breakpoint(breakpoint: Breakpoint); // Making program stop at certain line: "L<num>"
	case DisableBreakpoint(index: int);  // Enable breakpoint by index
	case EnableBreakpoint(index: int);   // Disable breakpoint by index
	case Unknown(cmd: string);
	case Quit;
}

// Implement a 
class SsaDebugger(interp: SsaInterpreter) {
	def parser = DebuggerParser.new();
	def bps = Vector<Breakpoint>.new();
	def printer = SsaPrinter.new();
	var startDel: Closure;
	var startArgs: Array<Val>;
	var running: bool;

	def invoke(del: Closure, args: Array<Val>) -> Result {
		startDel = del;
		startArgs = args;
		interp.setTrace(true);
		var readCommand = true;
		while (readCommand) {
			var command = parser.parseCommand(parser.getCommand());
			readCommand = handleCommand(command);
		}
		return null;
	}
	def handleCommand(command: DbgCommand) -> bool {
		match (command) {
			Run => {
				start();
				execute(true, false, false);
			}
			Continue => execute(true, false, false);
			Step => execute(false, true, false);
			Stepi => execute(false, false, false);
			Next => execute(false, true, true);
			Nexti => execute(false, false, true);
			Info(info) => {
				match (info) {
					Breakpoints => {
						for (i < bps.length) Terminal.put2("%d: %q\n", i, bps[i].render);
					}
					Locals => Terminal.put("Not implemented yet\n");
					Invalid(args) => Terminal.put1("Invalid info args: %s\n", args);
				}
			}
			Breakpoint(breakpoint) => {
				match (breakpoint) {
					x: LineBreakpoint => bps.put(x);
					_ => Terminal.put1("Invalid breakpoint args: %q\n", breakpoint.render);
				}
			}
			DisableBreakpoint(index) => {
				if (index < bps.length) bps[index].disable();
				else Terminal.put1("Invalid breakpoint: %d\n", index);
			}
			EnableBreakpoint(index) => {
				if (index < bps.length) bps[index].enable();
				else Terminal.put1("Invalid breakpoint: %d\n", index);
			}
			Unknown(cmd) => {
				Terminal.put("Unknown command\n");
			}
			Quit => {
				return false;
			}
		}
		return true;
	}
	def start() {
		interp.reset();
		Terminal.put("Start...\n");
		interp.pushFrame(startDel.memberRef, startDel.val, startArgs);
		running = true;
	}
	def execute(untilBreak: bool, nextLine: bool, jumpFunction: bool) {
		if (!running) start(); // ???: start or return?
		var targetSp = interp.sp;
		var n = interp.step(interp.frame.ip);
		if (interp.frame == null) {
			running = false;
			printExecuteResult();
			return;
		}
		interp.frame.ip = n;
		while (!stopExecute(n, untilBreak, nextLine, jumpFunction, targetSp)) {
			n = interp.step(interp.frame.ip);
			if (interp.frame == null) {
				running = false;
				break;
			}
			interp.frame.ip = n;
		}
		printExecuteResult();
	}
	def stopExecute(instr: SsaInstr, untilBreak: bool, nextLine: bool, jumpFunction: bool, targetSp: int) -> bool {
		if (isBreakpoint(instr)) return true;
		if (untilBreak) return false;
		if (!nextLine && !jumpFunction) return true;
		if (jumpFunction && interp.sp > targetSp) return false;
		if (!nextLine || (nextLine && SsaCheckpoint.?(instr))) return true;
		return false;
	}
	def isBreakpoint(instr: SsaInstr) -> bool {
		if (!SsaCheckpoint.?(instr)) return false;
		var checkpoint = SsaCheckpoint.!(instr);
		if (checkpoint.breakpoint) return true;
		for (i < bps.length) {
			if (LineBreakpoint.?(bps[i])) {
				var x = LineBreakpoint.!(bps[i]);
				if (x.on && x.line == checkpoint.source.line) {
					checkpoint.breakpoint = true;
					bps[i] = SsaCPBreakpoint.new(checkpoint);
					return true;
				}
			}
		}
		return false;
	}
	def printExecuteResult() {
		if (interp.frame != null) {
			for (j < interp.sp-1) printer.buf.puts("  ");
			printer.buf.puts("=>");
			printer.printInstr(interp.frame.ip, false, false, false);
			printer.outln();
		} else {
			var result = if (interp.exception == null, interp.retVal, interp.exception);
			var rettype = interp.prog.getMain().getReturnType();
			printer.buf.puts("Program exited: ");
			V3.renderResult(result, rettype, printer.buf);
			printer.outln();
		}
	}
}

class DebuggerParser {
	def STDIN = 0;

	def getCommand() -> string {
		var sb = StringBuilder.new();
		System.puts("(debug) ");
		var ch = byte.!(System.fileRead(STDIN));
		while (ch != '\n') {
			sb.putc(ch);
			ch = byte.!(System.fileRead(STDIN));
		}
		return sb.extract();
	}
	def parseCommand(command: string) -> DbgCommand {
		var name: string;
		var args: string;
		for (i < command.length) {
			if (command[i] == ' ') {
				name = Arrays.range(command, 0, i);
				args = Arrays.range(command, i + 1, command.length);
				break;
			}
			if (i == command.length - 1) name = command;
		}

		if (name == null) {
			return DbgCommand.Unknown("");
		} else if (Strings.equal(name, "run") || Strings.equal(name, "r")) {
			return DbgCommand.Run;
		} else if (Strings.equal(name, "continue") || Strings.equal(name, "c")) {
			return DbgCommand.Continue;
		} else if (Strings.equal(name, "step") || Strings.equal(name, "s")) {
			return DbgCommand.Step;
		} else if (Strings.equal(name, "stepi") || Strings.equal(name, "si")) {
			return DbgCommand.Stepi;
		} else if (Strings.equal(name, "next") || Strings.equal(name, "n")) {
			return DbgCommand.Next;
		} else if (Strings.equal(name, "nexti") || Strings.equal(name, "ni")) {
			return DbgCommand.Nexti;
		} else if (Strings.equal(name, "info")) {
			return DbgCommand.Info(parseInfo(args));
		} else if (Strings.equal(name, "breakpoint") || Strings.equal(name, "b")) {
			return DbgCommand.Breakpoint(parseBreakpoint(args));
		} else if (Strings.equal(name, "disable")) {
			return DbgCommand.DisableBreakpoint(Ints.parseDecimal(args, 0).1);
		} else if (Strings.equal(name, "enable")) { 
			return DbgCommand.EnableBreakpoint(Ints.parseDecimal(args, 0).1);
		} else if (Strings.equal(name, "quit") || Strings.equal(name, "q")) {
			return DbgCommand.Quit;
		}
		return DbgCommand.Unknown(command);
	}
	def parseInfo(args: string) -> Info {
		if (args == null) {
			return Info.Invalid("");
		} else if (Strings.equal(args, "break")) {
			return Info.Breakpoints;
		} else if (Strings.equal(args, "locals")) {
			return Info.Locals;
		}
		return Info.Invalid(args);
	}
	def parseBreakpoint(args: string) -> Breakpoint {
		if (args == null) return InvalidBreakpoint.new("");
		if (args[0] != 'L') return InvalidBreakpoint.new(args);
		var result = Ints.parseDecimal(args, 1);
		var line = result.1;
		if (result.0 + 1 == args.length) return LineBreakpoint.new(line, true);
		return InvalidBreakpoint.new(args);
	}
}
type Info {
	case Breakpoints;
	case Locals;
	case Invalid(args: string);
}
class Breakpoint {
	def render(out: StringBuilder) -> StringBuilder;
	def disable();
	def enable();
}
class LineBreakpoint(line: int, var on: bool) extends Breakpoint {
	def render(out: StringBuilder) -> StringBuilder { return out.put2("L:%d (%z)", line, on); }
	def disable() { on = false; }
	def enable() { on = true; }
}
class SsaCPBreakpoint(ssa: SsaCheckpoint) extends Breakpoint {
	def render(out: StringBuilder) -> StringBuilder { 
		return out.put2("%q (%z)", ssa.source.render, ssa.breakpoint);
	}
	def disable() { ssa.breakpoint = false; }
	def enable() { ssa.breakpoint = true; }
}
class InvalidBreakpoint(args: string) extends Breakpoint {
	def render(out: StringBuilder) -> StringBuilder { return out.puts(args); }
	def disable() {}
	def enable() {}
}
