// Copyright 2023 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

type DbgCommand {
	case Run;      // Begin program
	case Continue; // Continue program
	case Step;     // Step program until it reaches a different source line
	case Stepi;    // Step one instruction exactly
	case Next;     // Step program, jumping over calls
	case Nexti;    // Step one instruction, jumping over calls
	case Info(info: Info);   // Show breakpoints: "break" or locals: "local"
	case Breakpoint(breakpoint: Breakpoint); // Making program stop at certain line: "<fileName> <line>"
	case DisableBreakpoint(index: int);  // Enable breakpoint by index
	case EnableBreakpoint(index: int);   // Disable breakpoint by index
	case Backtrace;
	case Trace(on: bool);    // Switch "on"/"off" of tracing execution
	case Unknown(cmd: string);
	case Quit;     // Quit the debugger
}

// Implement a GDB-like interface debugger based on SsaInterpreter
class SsaDebugger(prog: Program, interp: SsaInterpreter) {
	def parser = DebuggerParser.new();
	def bps = Vector<Breakpoint>.new();
	def printer = SsaPrinter.new();
	var startDel: Closure;
	var startArgs: Array<Val>;
	var running: bool;

	def invoke(del: Closure, args: Array<Val>) -> Result {
		startDel = del;
		startArgs = args;
		var readCommand = true;
		while (readCommand) {
			var command = parser.parseCommand(parser.getCommand());
			readCommand = handleCommand(command);
		}
		return null;
	}
	def handleCommand(command: DbgCommand) -> bool {
		match (command) {
			Run => {
				start();
				execute(true, false, false);
			}
			Continue => execute(true, false, false);
			Step => execute(false, true, false);
			Stepi => execute(false, false, false);
			Next => execute(false, true, true);
			Nexti => execute(false, false, true);
			Info(info) => {
				match (info) {
					Breakpoints => {
						for (i < bps.length) Terminal.put2("%d: %q\n", i, bps[i].render);
					}
					Locals => Terminal.put("Not implemented yet\n");
					Invalid(args) => Terminal.put1("Invalid info args: %s\n", args);
				}
			}
			Breakpoint(breakpoint) => {
				match (breakpoint) {
					x: LineBreakpoint => {
						for (i < prog.files.length) {
							Terminal.put1("input %s\n", prog.files[i]);
							if (Strings.equal(prog.files[i], x.fileName)) {
								bps.put(x);
								return true;
							}
						}
						Terminal.put1("Invalid breakpoint args: %q\n", x.renderArgs);
					}
					_ => Terminal.put1("Invalid breakpoint args: %q\n", breakpoint.render);
				}
			}
			DisableBreakpoint(index) => {
				if (index < bps.length) bps[index].disable();
				else Terminal.put1("Invalid breakpoint: %d\n", index);
			}
			EnableBreakpoint(index) => {
				if (index < bps.length) bps[index].enable();
				else Terminal.put1("Invalid breakpoint: %d\n", index);
			}
			Backtrace => {
				if (running) {
					var source: Source;
					if (SsaCheckpoint.?(interp.frame.ip)) source = SsaCheckpoint.!(interp.frame.ip).source;
					var trace = interp.getStackTrace(source);
					for (list = trace; list != null; list = list.tail) {
						for (s = list.head; s != null; s = s.tail) {
							Terminal.put1("\t%q\n", s.render);
						}
					}
				}
			}
			Trace(on) => {
				interp.setTrace(on);
			}
			Unknown(cmd) => {
				Terminal.put("Unknown command\n");
			}
			Quit => {
				return false;
			}
		}
		return true;
	}
	def start() {
		interp.reset();
		Terminal.put1("Starting program: %s\n", interp.prog.name());
		interp.pushFrame(startDel.memberRef, startDel.val, startArgs);
		running = true;
	}
	def execute(untilBreak: bool, nextLine: bool, jumpFunction: bool) {
		if (!running) start(); // ???: start or return?
		var targetSp = interp.sp;
		var n = interp.step(interp.frame.ip);
		if (interp.frame == null) {
			running = false;
			printExecuteResult();
			return;
		}
		interp.frame.ip = n;
		while (!stopExecute(n, untilBreak, nextLine, jumpFunction, targetSp)) {
			n = interp.step(interp.frame.ip);
			if (interp.frame == null) {
				running = false;
				break;
			}
			interp.frame.ip = n;
		}
		printExecuteResult();
	}
	def stopExecute(instr: SsaInstr, untilBreak: bool, nextLine: bool, jumpFunction: bool, targetSp: int) -> bool {
		if (isBreakpoint(instr)) return true;
		if (untilBreak) return false;
		if (!nextLine && !jumpFunction) return true;
		if (jumpFunction && interp.sp > targetSp) return false;
		if (!nextLine || (nextLine && SsaCheckpoint.?(instr))) return true;
		return false;
	}
	def isBreakpoint(instr: SsaInstr) -> bool {
		if (!SsaCheckpoint.?(instr)) return false;
		var checkpoint = SsaCheckpoint.!(instr);
		if (checkpoint.breakpoint) return true;
		for (i < bps.length) {
			if (LineBreakpoint.?(bps[i])) {
				var x = LineBreakpoint.!(bps[i]), s = checkpoint.source;
				if (x.on && Strings.equal(x.fileName, s.mdecl.token.fileName) && x.line == s.line) {
					checkpoint.breakpoint = true;
					bps[i] = SsaCPBreakpoint.new(checkpoint);
					return true;
				}
			}
		}
		return false;
	}
	def printExecuteResult() {
		if (interp.frame != null) {
			for (j < interp.sp-1) printer.buf.puts("  ");
			printer.buf.blue().puts("=>").end();
			printer.printInstr(interp.frame.ip, false, false, false);
			printer.outln();
		} else {
			var result = if (interp.exception == null, interp.retVal, interp.exception);
			var rettype = interp.prog.getMain().getReturnType();
			printer.buf.puts("Program exited: ");
			V3.renderResult(result, rettype, printer.buf);
			printer.outln();
		}
	}
}

class DebuggerParser {
	def STDIN = 0;

	def getCommand() -> string {
		var sb = StringBuilder.new();
		System.puts("(debug) ");
		var ch = byte.!(System.fileRead(STDIN));
		while (ch != '\n') {
			sb.putc(ch);
			ch = byte.!(System.fileRead(STDIN));
		}
		return sb.extract();
	}
	def parseCommand(command: string) -> DbgCommand {
		var name: string;
		var args: string;
		for (i < command.length) {
			if (command[i] == ' ') {
				name = Arrays.range(command, 0, i);
				args = Arrays.range(command, i + 1, command.length);
				break;
			}
			if (i == command.length - 1) name = command;
		}

		if (name == null) {
			return DbgCommand.Unknown("");
		} else if (Strings.equal(name, "run") || Strings.equal(name, "r")) {
			return DbgCommand.Run;
		} else if (Strings.equal(name, "continue") || Strings.equal(name, "c")) {
			return DbgCommand.Continue;
		} else if (Strings.equal(name, "step") || Strings.equal(name, "s")) {
			return DbgCommand.Step;
		} else if (Strings.equal(name, "stepi") || Strings.equal(name, "si")) {
			return DbgCommand.Stepi;
		} else if (Strings.equal(name, "next") || Strings.equal(name, "n")) {
			return DbgCommand.Next;
		} else if (Strings.equal(name, "nexti") || Strings.equal(name, "ni")) {
			return DbgCommand.Nexti;
		} else if (Strings.equal(name, "info")) {
			return DbgCommand.Info(parseInfo(args));
		} else if (Strings.equal(name, "breakpoint") || Strings.equal(name, "b")) {
			return DbgCommand.Breakpoint(parseBreakpoint(args));
		} else if (Strings.equal(name, "disable")) {
			return DbgCommand.DisableBreakpoint(Ints.parseDecimal(args, 0).1);
		} else if (Strings.equal(name, "enable")) { 
			return DbgCommand.EnableBreakpoint(Ints.parseDecimal(args, 0).1);
		} else if (Strings.equal(name, "backtrace") || Strings.equal(name, "bt")) {
			return DbgCommand.Backtrace;
		} else if (Strings.equal(name, "trace")) {
			return DbgCommand.Trace(parseTrace(args));
		} else if (Strings.equal(name, "quit") || Strings.equal(name, "q")) {
			return DbgCommand.Quit;
		}
		return DbgCommand.Unknown(command);
	}
	def parseInfo(args: string) -> Info {
		if (args == null) {
			return Info.Invalid("");
		} else if (Strings.equal(args, "break")) {
			return Info.Breakpoints;
		} else if (Strings.equal(args, "locals")) {
			return Info.Locals;
		}
		return Info.Invalid(args);
	}
	def parseBreakpoint(args: string) -> Breakpoint {
		if (args == null) return InvalidBreakpoint.new("");
		for (i < args.length) {
			if (args[i] == ' ') {
				var fileName = Arrays.range(args, 0, i);
				if (!Strings.endsWith(fileName, ".v3")) {
					fileName = Strings.format1("%s.v3", fileName);
				}
				var line = Ints.parseDecimal(args, i+1).1;
				return LineBreakpoint.new(fileName, line, true);
			}
		}
		return InvalidBreakpoint.new(args);
	}
	def parseTrace(args: string) -> bool {
		if (args == null || Strings.equal(args, "on")) return true;
		else return false;
	}
}
type Info {
	case Breakpoints;
	case Locals;
	case Invalid(args: string);
}
class Breakpoint {
	def render(out: StringBuilder) -> StringBuilder;
	def disable();
	def enable();
}
class LineBreakpoint(fileName: string, line: int, var on: bool) extends Breakpoint {
	def render(out: StringBuilder) -> StringBuilder {
		return out.put3("[%s @ %d] (%z)", fileName, line, on);
	}
	def renderArgs(out: StringBuilder) -> StringBuilder {
		return out.put2("%s %d", fileName, line);
	}
	def disable() { on = false; }
	def enable() { on = true; }
}
class SsaCPBreakpoint(ssa: SsaCheckpoint) extends Breakpoint {
	def render(out: StringBuilder) -> StringBuilder { 
		return out.put2("%q (%z)", ssa.source.render, ssa.breakpoint);
	}
	def disable() { ssa.breakpoint = false; }
	def enable() { ssa.breakpoint = true; }
}
class InvalidBreakpoint(args: string) extends Breakpoint {
	def render(out: StringBuilder) -> StringBuilder { return out.puts(args); }
	def disable() {}
	def enable() {}
}
