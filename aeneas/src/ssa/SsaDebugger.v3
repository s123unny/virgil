// Copyright 2023 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum DbgCommand(cmdName: string, alias: string, help: string) {
	Help("help", "h", "Print help text"),
	Run("run", "r", "Begin program"),
	Start("start", "start", "Set a temporary breakpoint on main() and begin program")
	Continue("continue", "c", "Continue program"),
	Step("step", "s", "Step program until it reaches a different source line"),
	Stepi("stepi", "si", "Step one instruction exactly"),
	Next("next", "n", "Step program, jumping over calls"),
	Nexti("nexti", "ni", "Step one instruction, jumping over calls"),
	Finish("finish", "fin", "Execute until selected stack frame returns"),
	Info("info", "info", "Show breakpoints or locals. Type \"help info\" for more help"),
	Breakpoint("breakpoint", "b", "Making program stop at certain line: <fileName> <line>"),
	DisableBreakpoint("disable", "disable", "Enable breakpoint by <index>"),
	EnableBreakpoint("enable", "enable", "Disable breakpoint by <index>"),
	Backtrace("backtrace", "bt", "Print a backtrace"),
	Source("source", "source", "Print source with execution result along with a <line number>"),
	Display("display", "display", "Print information during stepping program. Type \"help display\" for more help"),
	Undisplay("undisplay", "undisplay", "Don't print information during stepping program"),
	Quit("quit", "q", "Quit the debugger"),
	Unknown("unknown", "unknown", ""),
}
enum DbgInfo(cmdName: string, alias: string, help: string) {
	Breakpoints("breakpoints", "b", "Print information about breakpoints"),
	Locals("locals", "l", "Print information about nonSsa-locals when next instr is a Checkpoint"),
	Inputs("inputs", "i", "Print information about inputs of next instruction"),
	Variable("variable", "v", "Print detail information about a variable"),
	Invalid("invalid", "invalid", "")
}
enum DbgDisplay(cmdName: string, alias: string, help: string) {
	Trace("trace", "t", "Trace execution for each instruction"),
	Source("source", "s", "Print source after each stepping instruction"),
	CalleeSource("callee-source", "ss", "Print callee's source as well"),
	Invalid("invalid", "invalid", ""),
}

def PRINT_LIMIT = 30;

enum DbgExecuteOpt(stopFunc: (SsaInstr, int, int) -> bool) {
	Continue(stopExecuteUntilBreak),
	Step(stopExecuteStep),
	Stepi(stopExecuteStepi),
	Next(stopExecuteNext),
	Nexti(stopExecuteNexti),
	Finish(stopExecuteUntilFin),
}
def stopExecuteUntilBreak(instr: SsaInstr, interpSp: int, targetSp: int) -> bool {
	return false;
}
def stopExecuteUntilFin(instr: SsaInstr, interpSp: int, targetSp: int) -> bool {
	if (interpSp < targetSp) return true;
	else return false;
}
var firstTime = true;
def stopExecuteStepi(instr: SsaInstr, interpSp: int, targetSp: int) -> bool {
	return true;
}
def stopExecuteStep(instr: SsaInstr, interpSp: int, targetSp: int) -> bool {
	if (SsaCheckpoint.?(instr)) return true;
	else return false;
}
def stopExecuteNexti(instr: SsaInstr, interpSp: int, targetSp: int) -> bool {
	if (interpSp > targetSp) return false;
	else return true;
}
def stopExecuteNext(instr: SsaInstr, interpSp: int, targetSp: int) -> bool {
	if (interpSp > targetSp) return false;
	else if (SsaCheckpoint.?(instr)) return true;
	else return false;
}

enum DbgStopReason {
	stopOnBreakpoint,
	stopOnStep,
	stopOnEntry,
	end,
}

class DbgFrame {
	def localVars = Vector<DbgFrameEntry>.new();
}
type DbgFrameEntry(name: string, t: Type, index: int, instr: SsaInstr) #unboxed { }

def INITIAL_FRAMES = 16;

// Implement a GDB-like interface debugger based on SsaInterpreter
class SsaDebugger(prog: Program, genSsa: (IrSpec, int) -> SsaGraph, interp: SsaInterpreter) {
	def parser = DebuggerParser.new();
	def bps = Vector<Breakpoint>.new();
	def printer = SsaPrinter.new();
	def srcPrinter = SrcPrinter.new(prog.vst.files, interp);
	var fileMethods: Array<Vector<VstMethod>>;
	var startDel: Closure;
	var startArgs: Array<Val>;
	var running: bool;
	var stopReason: DbgStopReason;
	var stack = Array<DbgFrame>.new(INITIAL_FRAMES);
	var frame: DbgFrame;
	var ip: SsaInstr;

	def invoke(del: Closure, args: Array<Val>) -> Result {
		startDel = del;
		startArgs = args;
		if (!CLOptions.DEBUG_EXTENSION.get()) Terminal.put("For help, type \"help\".\n");
		var readCommand = true;
		while (readCommand) {
			var result = parser.parseCommand(parser.getCommand());
			readCommand = handleCommand(result);
		}
		return null;
	}
	def handleCommand(command: DbgCommand, args: string) -> bool {
		match (command) {
			Help => printHelp(args);
			Run => {
				start(false);
				execute(DbgExecuteOpt.Continue);
			}
			Start => {
				start(true);
			}
			Continue => execute(DbgExecuteOpt.Continue);
			Step => execute(DbgExecuteOpt.Step);
			Stepi => execute(DbgExecuteOpt.Stepi);
			Next => execute(DbgExecuteOpt.Next);
			Nexti => execute(DbgExecuteOpt.Nexti);
			Finish => execute(DbgExecuteOpt.Finish);
			Info => {
				var info = parser.parseInfo(args);
				match (info.0) {
					Breakpoints => {
						for (i < bps.length) Terminal.put2("%d: %q\n", i, bps[i].render);
					}
					Locals => infoLocals();
					Inputs => infoInputs();
					Variable => {
						if (running) {
							var res = infoVal(info.1);
							if (!res && !CLOptions.DEBUG_EXTENSION.get()) Terminal.put("Nothing to show\n");
						}
						if (CLOptions.DEBUG_EXTENSION.get()) Terminal.put("variableDone\n");
					}
					Invalid => Terminal.put1("Invalid info args: %s\n", args);
				}
			}
			Breakpoint => {
				var result = parser.parseBreakpoint(args);
				var idx = -1, source: Source;
				if (result.0.length > 0 && insertBreakpoint(result)) {
					idx = bps.length-1;
					source = bps[idx].ssa.source;
				}
				putBreakpoint(args, idx, source);
			}
			DisableBreakpoint => {
				handleBreakpoint(args, false);
			}
			EnableBreakpoint => {
				handleBreakpoint(args, true);
			}
			Backtrace => {
				if (running) {
					var source: Source;
					if (SsaCheckpoint.?(interp.frame.ip)) source = SsaCheckpoint.!(interp.frame.ip).source;
					var trace = interp.getStackTrace(source);
					for (list = trace; list != null; list = list.tail) {
						for (s = list.head; s != null; s = s.tail) {
							putBacktrace(s);
						}
					}
				}
			}
			Source => {
				var result = parser.parseSource(args);
				if (result == INVALID) Terminal.put1("Invalid source args: %s\n", args);
				else srcPrinter.outN(result);
			}
			Display => {
				var display = parser.parseDisplay(args);
				match (display) {
					Trace => interp.setTrace(true);
					Source => srcPrinter.set(true);
					CalleeSource => srcPrinter.traceCallee = true;
					Invalid => {}
				}
			}
			Undisplay => {
				var display = parser.parseDisplay(args);
				match (display) {
					Trace => interp.setTrace(false);
					Source => srcPrinter.set(false);
					CalleeSource => srcPrinter.traceCallee = false;
					Invalid => Terminal.put1("Invalid display args: %s\n", args);
				}
			}
			Unknown => {
				Terminal.put("Unknown command\n");
			}
			Quit => {
				return false;
			}
		}
		return true;
	}
	// Start the program to be debugged in the interpreter
	def start(stopOnEntry: bool) {
		interp.reset();
		srcPrinter.reset();
		if (!CLOptions.DEBUG_EXTENSION.get()) {
			Terminal.put2("Starting program: %s with method %q\n", interp.prog.name(), startDel.memberRef.render);
			if (startArgs != null) {
				for (i < startArgs.length) Terminal.put2("args %d: %s\n", i, V3.renderVal(startArgs[i]));
			}
		}
		interp.pushFrame(startDel.memberRef, startDel.val, startArgs);
		updateLocals(0);
		running = true;
		if (stopOnEntry) {
			stopReason = DbgStopReason.stopOnEntry;
			var targetSp = interp.sp;
			ip = interp.frame.ip;
			while (!stopExecute(ip, DbgExecuteOpt.Step, targetSp)) {
				step(targetSp);
				if (!running) break;
			}
			printExecuteResult();
		}
	}
	// Step debugged program and stop depending on condition
	def execute(opt: DbgExecuteOpt) {
		if (!running) return;
		stopReason = DbgStopReason.stopOnStep;
		var targetSp = interp.sp;
		step(targetSp);
		while (running && !stopExecute(ip, opt, targetSp)) {
			step(targetSp);
		}
		if (srcPrinter.on) srcPrinter.out();
		printExecuteResult();
	}
	def step(targetSp: int) {
		var prevSp = interp.sp, prev = interp.frame.ip;
		var n = interp.step(prev);
		if (interp.frame == null) {
			stopReason = DbgStopReason.end;
			running = false;
			return;
		}
		srcPrinter.putData(prev, targetSp);
		interp.frame.ip = n;
		updateLocals(prevSp);
		ip = interp.frame.ip;
	}
	// Decide whether to stop execution or not
	def stopExecute(instr: SsaInstr, opt: DbgExecuteOpt, targetSp: int) -> bool {
		if (SsaNewVar.?(instr) || SsaDeleteVar.?(instr)) return false;
		if (isBreakpoint(instr)) {
			stopReason = DbgStopReason.stopOnBreakpoint;
			return true;
		}
		return opt.stopFunc(instr, interp.sp, targetSp);
	}
	def isBreakpoint(instr: SsaInstr) -> bool {
		if (!SsaCheckpoint.?(instr)) return false;
		var checkpoint = SsaCheckpoint.!(instr);
		if (checkpoint.breakpoint) return true;
		else return false;
	}
	def updateLocals(prevSp: int) {
		var sp = interp.sp;
		if (sp > prevSp) {
			if (sp >= stack.length) stack = Arrays.grow(stack, stack.length * 4);
			frame = stack[sp];
			if (frame == null) frame = stack[sp] = DbgFrame.new();
			frame.localVars.resize(0);
		} else if (sp < prevSp) {
			frame = stack[sp];
		}
		if (SsaNewVar.?(interp.frame.ip)) {
			var ip = SsaNewVar.!(interp.frame.ip);
			var instr: SsaInstr = if (ip.index == -1, ip.inputs[0].dest);
			frame.localVars.put(DbgFrameEntry(ip.name, ip.vtype, ip.index, instr));
		} else if (SsaDeleteVar.?(interp.frame.ip)) {
			var resizeTo = frame.localVars.length - SsaDeleteVar.!(interp.frame.ip).n;
			frame.localVars.resize(resizeTo);
		}
	}
	// Print next instruction or the final result of the debugger program
	def printExecuteResult() {
		if (CLOptions.DEBUG_EXTENSION.get()) {
			Terminal.put1("stop|%s\n", stopReason.name);
			if (interp.frame == null) printProgramResult();
			return;
		}
		if (interp.frame != null) {
			for (j < interp.sp-1) printer.buf.puts("  ");
			printer.buf.blue().puts("=>").end();
			printer.printInstr(ip, false, true, false, false);
			printer.outln();
		} else {
			printProgramResult();
		}
	}
	def printProgramResult() {
		var result = if (interp.exception == null, interp.retVal, interp.exception);
		var rettype = interp.prog.getMain().getReturnType();
		if (CLOptions.DEBUG_EXTENSION.get()) printer.buf.puts("result|");
		else printer.buf.puts("Program exited: ");
		V3.renderResult(result, rettype, printer.buf);
		printer.outln();
	}
	def infoLocals() {
		if (!running || !SsaCheckpoint.?(ip)) return;
		var inputs = ip.inputs;
		var more = false;
		for (i < frame.localVars.length) {
			var v = frame.localVars[i];
			var instr = if (v.index >= 0, inputs[v.index].dest, v.instr);
			var val = interp.getVal(instr);
			putVal(i, v.name, val, v.t);
			if (Record.?(val)) more = true;
		}
		moreInfo(more);
	}
	def infoInputs() {
		if (!running) return;
		var inputs = ip.inputs;
		var vtypes = if (SsaApplyOp.?(ip), SsaApplyOp.!(ip).op.typeArgs);
		var more = false;
		for (i < inputs.length) {
			var instr = inputs[i].dest;
			var vtype = if(vtypes != null && i < vtypes.length, vtypes[i]);
			vtype = if(vtype == null && SsaConst.?(instr), SsaConst.!(instr).vtype, vtype);
			var val = interp.getVal(instr);
			putVal(i, null, val, vtype);
			if (Record.?(val)) more = true;
		}
		moreInfo(more);
	}
	def moreInfo(more: bool) {
		if (more && !CLOptions.DEBUG_EXTENSION.get()) {
			Terminal.put("More info? (index): ");
			var result = parser.getInt();
			if (result.0) infoVal([result.1]);
		}
	}
	def infoVal(infoIdx: Array<int>) -> bool {
		var instr: SsaInstr;
		var inputs = ip.inputs;
		match(ip) {
			x: SsaApplyOp => {
				if (infoIdx[0] < inputs.length) {
					instr = inputs[infoIdx[0]].dest;
				}
			}
			x: SsaCheckpoint => {
				if (infoIdx[0] < frame.localVars.length) {
					var v = frame.localVars[infoIdx[0]];
					instr = if (v.index >= 0, inputs[v.index].dest, v.instr);
				}
			}
		}
		if (instr == null) return false;
		var val = interp.getVal(instr);
		for (j = 1; j < infoIdx.length; j++) {
			if (Record.?(val) && infoIdx[j] < Record.!(val).values.length) val = Record.!(val).values[infoIdx[j]];
			else return false;
		}
		if (!Record.?(val)) return false;
		var r = Record.!(val), line = r.values.length;
		if (!CLOptions.DEBUG_EXTENSION.get() && line > PRINT_LIMIT) {
			Terminal.put1("Do you wish to see all output (%d lines)? ", line);
			if (!parser.getBool()) return true;
		}
		match(r.rtype) {
			x: ClassType => {
				var irclass = prog.ir.getIrClass(r.rtype);
				for (i < r.values.length) {
					var name = irclass.fields[i].render(StringBuilder.new()).toString();
					putVal(i, name, r.values[i], irclass.fields[i].fieldType);
				}
			}
			x: ArrayType => {
				for (i < r.values.length) {
					putVal(i, null, r.values[i], x.elementType());
				}
			}
			_ => return false;
		}
		return true;
	}
	
	def insertBreakpoint(fileName: string, line: int) -> bool {
		for (i < prog.files.length) {
			if (Strings.equal(prog.files[i], fileName)) {
				if (line <= prog.vst.files[i].lineEnds.length + 1) {
					var vstFile = prog.vst.files[i];
					for (i < vstFile.classes.length) {
						if (insertBreakpointVst(vstFile.classes[i], line)) return true;
					}
					for (i < vstFile.components.length) {
						if (insertBreakpointVst(vstFile.components[i], line)) return true;
					}
				}
				return false;
			}
		}
		return false;
	}
	def insertBreakpointVst(vstCompound: VstCompound, line: int) -> bool {
		var vstMethods = Vector<VstMethod>.new();
		var members = vstCompound.members;
		for (l = members; l != null; l = l.tail) {
			if (VstMethod.?(l.head) && VstMethod.!(l.head).body.range().contains(line, 0)) {
				vstMethods.put(VstMethod.!(l.head));
			}
		}
		for (i < vstMethods.length) {
			if (insertBreakpointM(vstCompound, vstMethods[i], line)) return true;
		}
		return false;
	}
	def insertBreakpointM(vstCompound: VstCompound, vstMethod: VstMethod, line: int) -> bool {
		var ctype = vstCompound.getDeclaredType();
		var irClass = prog.ir.getIrClass(ctype);
		var irMethod: IrMethod;
		for (m in irClass.methods) {
			if (m != null && m.source == vstMethod) {
				irMethod = m;
				break;
			}
		}
		if (irMethod == null) return false;
		// Generate ssa if haven't
		if (irMethod.ssa == null) {
			var spec = prog.ir.fromVstMember(vstMethod);
			irMethod.ssa = genSsa(spec, 0);
		}
		// Iterate ssa to find SsaCheckpoint pointing to line
		var blocks = irMethod.ssa.bfBlocks(null);
		for (b in blocks) {
			for (i = b.next; i != null && i != b; i = i.next) {
				match(i) {
					x: SsaCheckpoint => {
						if (x.source.line == line) {
							bps.put(Breakpoint.new(x));
							return true;
						}
					}
				}
			}
		}
		return false;
	}
	// Enable/Disable a breakpoint
	def handleBreakpoint(args: string, on: bool) {
		var result = Ints.parseDecimal(args, 0);
		if (args.length == 0 || result.0 != args.length) {
			Terminal.put1("Invalid breakpoint: %s\n", args);
		} else {
			var index = result.1;
			if (index < bps.length) {
				if (on) bps[index].enable();
				else bps[index].disable();
			} else Terminal.put1("Invalid breakpoint: %d\n", index);
		}
	}
	def printHelp(args: string) {
		var id: int;
		if (args.length == 0) {
			for (cmd in DbgCommand) printHelpCmd(cmd.cmdName, cmd.alias, cmd.help);
		} else if (Strings.equal(args, "info")) {
			for (cmd in DbgInfo) printHelpCmd(cmd.cmdName, cmd.alias, cmd.help);
		} else if (Strings.equal(args, "display")) {
			for (cmd in DbgDisplay) printHelpCmd(cmd.cmdName, cmd.alias, cmd.help);
		}
	}
	def printHelpCmd(cmdName: string, alias: string, help: string) {
		if (Strings.equal(cmdName, alias)) printer.buf.puts(cmdName);
		else printer.buf.put2("%s/%s", cmdName, alias);
		printer.buf.pad(' ', 16);
		printer.buf.puts(help).outln();
	}
	def putBreakpoint(args: string, idx: int, source: Source) {
		if (CLOptions.DEBUG_EXTENSION.get()) Terminal.put2("breakpoint|%s|%d\n", args, idx);
		else {
			if (idx == -1) Terminal.put1("Invalid breakpoint args: %s\n", args);
			else Terminal.put2("Breakpoint %d %q\n", idx, source.render);
		}
	}
	def putVal(i: int, name: string, val: Val, vtype: Type) {
		if (CLOptions.DEBUG_EXTENSION.get()) {
			if (name == null) name = Strings.format1("%d", i);
			extPutVariable(i, name, val, vtype);
		} else {
			printer.buf.put1("%d. ", i);
			if (name != null) printer.buf.put1("%s: ", name);
			printer.buf.puthashv(val, vtype).end();
			printer.printColonType(vtype);
			printer.outln();
		}
	}
	def extPutVariable(idx: int, name: string, val: Val, vtype: Type) {
		// variable|idx|name|value|type|ref
		Terminal.put2("variable|%d|%s|", idx, name);
		V3.renderResult(val, vtype, printer.buf);
		printer.buf.putc('|');
		if (vtype != null) vtype.render(printer.buf);
		printer.buf.put1("|%z", (Record.?(val)));
		printer.outln();
	}
	def putBacktrace(s: Source) {
		if (!CLOptions.DEBUG_EXTENSION.get()) Terminal.put1("\t%q\n", s.render);
		else Terminal.put3("bt|%q|%s|%d\n", s.mdecl.renderLong, s.mdecl.token.fileName, s.line);
	}
}

def INVALID = -1;
class DebuggerParser {
	def STDIN = 0;

	def getCommand() -> string {
		var sb = StringBuilder.new();
		if (!CLOptions.DEBUG_EXTENSION.get()) Terminal.put("(debug) ");
		var ch = byte.!(System.fileRead(STDIN));
		while (ch != '\n') {
			sb.putc(ch);
			ch = byte.!(System.fileRead(STDIN));
		}
		return sb.extract();
	}
	def parseCommand(command: string) -> (DbgCommand, /*args*/string) {
		var name: string;
		var args: string = "";
		for (i < command.length) {
			if (command[i] == ' ') {
				name = Arrays.range(command, 0, i);
				args = Arrays.range(command, i + 1, command.length);
				break;
			}
			if (i == command.length - 1) name = command;
		}
		if (name == null) return (DbgCommand.Unknown, command);
		for (cmd in DbgCommand) {
			if (Strings.equal(name, cmd.cmdName) || Strings.equal(name, cmd.alias)) {
				return (cmd, args);
			}
		}
		return (DbgCommand.Unknown, command);
	}
	def parseInfo(args: string) -> (DbgInfo, Array<int>) {
		if (args.length == 0) return (DbgInfo.Invalid, null);
		var infoType = "";
		var infoIdx = Vector<int>.new();
		for (i < args.length) {
			if (args[i] == ' ') {
				infoType = Arrays.range(args, 0, i);
				var sepIdx = i + 1;
				while (sepIdx < args.length) {
					var result = Ints.parseDecimal(args, sepIdx);
					if (result.0 > 0) infoIdx.put(result.1);
					sepIdx += result.0 + 1;
				}
				break;
			}
		}
		if (infoType.length == 0) infoType = args;
		for (e in DbgInfo) {
			if (Strings.equal(infoType, e.alias) || Strings.equal(infoType, e.cmdName)) return (e, infoIdx.extract());
		}
		return (DbgInfo.Invalid, null);
	}
	def parseBreakpoint(args: string) -> (/*fileName*/string, /*line*/int) {
		if (args.length == 0) return ("", 0);
		for (i < args.length) {
			if (args[i] == ' ') {
				var fileName = Arrays.range(args, 0, i);
				if (!Strings.endsWith(fileName, ".v3")) {
					fileName = Strings.format1("%s.v3", fileName);
				}
				var result = Ints.parseDecimal(args, i+1);
				if (result.0 + i + 1 == args.length) {
					return (fileName, result.1);
				} else return ("", 0);
			}
		}
		return ("", 0);
	}
	def parseDisplay(args: string) -> DbgDisplay {
		if (args.length == 0) return DbgDisplay.Invalid;
		for (e in DbgDisplay) {
			if (Strings.equal(args, e.alias) || Strings.equal(args, e.cmdName)) return e;
		}
		return DbgDisplay.Invalid;
	}
	def parseSource(args: string) -> int {
		if (args.length == 0) return PRINT_LIMIT;
		var result = Ints.parseDecimal(args, 0);
		if (result.0 == args.length) return result.1;
		else return INVALID;
	}
	def getInt() -> (bool, int) {
		var sb = StringBuilder.new();
		var ch = byte.!(System.fileRead(STDIN));
		while (ch != '\n') {
			sb.putc(ch);
			ch = byte.!(System.fileRead(STDIN));
		}
		var input = sb.extract();
		if (input.length == 0) return (false, 0);
		var result = Ints.parseDecimal(input, 0);
		if (result.0 == input.length) return (true, result.1);
		else return (false, 0);
	}
	def getBool() -> bool {
		var sb = StringBuilder.new();
		var ch = byte.!(System.fileRead(STDIN));
		while (ch != '\n') {
			sb.putc(ch);
			ch = byte.!(System.fileRead(STDIN));
		}
		var input = sb.extract();
		if (input[0] == 'y' || input[0] == 'Y') return true;
		else return false;
	}
}
class Breakpoint {
	def ssa: SsaCheckpoint;
	new(ssa) {
		ssa.breakpoint = true;
	}
	def render(out: StringBuilder) -> StringBuilder { 
		return out.put2("%q (%z)", ssa.source.render, ssa.breakpoint);
	}
	def disable() { ssa.breakpoint = false; }
	def enable() { ssa.breakpoint = true; }
}

def storeLimit = 50;
def storeRemove = 10;
class SrcPrinter(vstFiles: Array<VstFile>, interp: SsaInterpreter) {
	def padNum = 6;
	def tmpBuf = TerminalBuffer.new();
	def outBuf = TerminalBuffer.new();
	def ends = Vector<int>.new();
	var on: bool;
	var traceCallee: bool;
	var indent: int;
	var cacheVstFile: VstFile;

	def set(on: bool) {
		this.on = on;
		if (on) reset();
	}
	def reset() {
		ends.resize(0);
		tmpBuf.reset();
		outBuf.reset();
	}
	def putData(instr: SsaInstr, targetSp: int) {
		if (!traceCallee && interp.sp != targetSp) return;
		if (SsaCheckpoint.?(instr)) {
			var source = SsaCheckpoint.!(instr).source;
			var point = FilePoint.new(null, source.line, source.column);
			var vstFile = getVstFile(source.mdecl.token.fileName);
			extractTmpConstraint(0);
			addEnds(outBuf.length);
			tmpBuf.putd(source.line).tab().rjustify(' ', padNum, padNum);
			putNewIndent(targetSp);
			outBuf.puts(tmpBuf.extract());
			outBuf.puts(point.extractLine(vstFile.input, vstFile.lineEnds)).ln();
		} else if (SsaApplyOp.?(instr)) {
			putVal(instr);
		} else if (SsaReturn.?(instr)) {
			var i = interp.stack[interp.sp - 1].ip; // Caller instr
			if (!SsaApplyOp.?(i)) return;
			putVal(i);
		}
	}
	def getVstFile(fileName: string) -> VstFile {
		if (cacheVstFile != null && Strings.equal(cacheVstFile.fileName, fileName)) return cacheVstFile;
		for (i < vstFiles.length) {
			if (Strings.equal(vstFiles[i].fileName, fileName)) {
				cacheVstFile = vstFiles[i];
				return cacheVstFile;
			}
		}
		return V3.fail("source filename not found");
	}
	def addEnds(i: int) {
		ends.put(i);
		if (ends.length > storeLimit) {
			var newBuf = Arrays.range(outBuf.buf, ends[storeRemove], outBuf.length);
			outBuf.reset();
			outBuf.puts(newBuf);
			var newEnds = Arrays.range(ends.array, storeRemove + 1, ends.length);
			for (j < newEnds.length) newEnds[j] -= ends[storeRemove];
			Vectors.overwrite(ends, newEnds);
		}
	}
	def putVal(instr: SsaInstr) {
		var vtype = instr.getType();
		if (VoidType.?(vtype) || instr.valueNum < 0) return;
		var source = SsaApplyOp.!(instr).source;
		if (source == null) {
			extractTmpConstraint(padNum);
			tmpBuf.pad(' ', padNum);
			V3.renderResult(interp.getVal(instr), vtype, tmpBuf);
			return;
		}
		var point = source.column - 1;
		var start = if(source.range.beginColumn != -1, source.range.beginColumn-1, point);
		var end = if(source.range.endColumn != -1, source.range.endColumn-1, point);
		extractTmpConstraint(start);
		tmpBuf.pad(' ', start);
		V3.renderResult(interp.getVal(instr), vtype, tmpBuf);
		tmpBuf.center('-', tmpBuf.length - start, end - start - 2);
		tmpBuf.center('|', tmpBuf.length - start, end - start);
	}
	def out() {
		extractTmpConstraint(0);
		outBuf.outt();
		ends.resize(0);
	}
	def outN(n: int) {
		if (ends.length == 0) return;
		var i = if (ends.length - n > 0, ends.length - n, 0);
		var s = Arrays.range(outBuf.buf, ends[i], outBuf.length);
		Terminal.put(s);
	}
	def putNewIndent(targetSp: int) {
		indent = 0;
		while (targetSp < interp.sp) {
			outBuf.tab();
			indent++;
			targetSp++;
		}
	}
	def extractTmpConstraint(len: int) {
		if (tmpBuf.length >= len) {
			putPad();
			putIndent();
			outBuf.valColor().puts(tmpBuf.ln().extract()).end();
		}
	}
	def putIndent() {
		for (i < indent) outBuf.tab();
	}
	def putPad() {
		for (i < padNum) outBuf.sp();
		outBuf.tab();
	}
}