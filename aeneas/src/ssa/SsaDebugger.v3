// Copyright 2023 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum DbgCommand(cmdName: string, alias: string, help: string) {
	Help("help", "h", "Print help text"),
	Run("run", "r", "Begin program"),
	Continue("continue", "c", "Continue program"),
	Step("step", "s", "Step program until it reaches a different source line"),
	Stepi("stepi", "si", "Step one instruction exactly"),
	Next("next", "n", "Step program, jumping over calls"),
	Nexti("nexti", "ni", "Step one instruction, jumping over calls"),
	Finish("finish", "fin", "Execute until selected stack frame returns"),
	Info("info", "info", "Show breakpoints or locals. Type \"help info\" for more help"),
	Breakpoint("breakpoint", "b", "Making program stop at certain line: <fileName> <line>"),
	DisableBreakpoint("disable", "disable", "Enable breakpoint by <index>"),
	EnableBreakpoint("enable", "enable", "Disable breakpoint by <index>"),
	Backtrace("backtrace", "bt", "Print a backtrace"),
	Source("source", "source", "Print source with execution result along with a <line number>"),
	Display("display", "display", "Print information during stepping program. Type \"help display\" for more help"),
	Undisplay("undisplay", "undisplay", "Don't print information during stepping program"),
	Quit("quit", "q", "Quit the debugger"),
	Unknown("unknown", "unknown", ""),
}
enum DbgInfo(cmdName: string, alias: string, help: string) {
	Breakpoints("breakpoints", "b", "Print information about breakpoints"),
	Locals("locals", "l", "Print information about nonSsa-locals when next instr is a Checkpoint"),
	Inputs("inputs", "i", "Print information about inputs of next instruction"),
	Invalid("invalid", "invalid", "")
}
enum DbgDisplay(cmdName: string, alias: string, help: string) {
	Trace("trace", "t", "Trace execution for each instruction"),
	Source("source", "s", "Print source after each stepping instruction"),
	CalleeSource("callee-source", "ss", "Print callee's source as well"),
	Invalid("invalid", "invalid", ""),
}

def PRINT_LIMIT = 30;

enum DbgExecuteOpt(untilBreak: bool, nextLine: bool, jump: bool, fin: bool) {
	Continue(true, false, false, false),
	Step(false, true, false, false),
	Stepi(false, false, false, false),
	Next(false, true, true, false),
	Nexti(false, false, true, false),
	Finish(false, false, false, true),
}

// Implement a GDB-like interface debugger based on SsaInterpreter
class SsaDebugger(prog: Program, genSsa: (IrSpec, int) -> SsaGraph, interp: SsaInterpreter) {
	def parser = DebuggerParser.new();
	def bps = Vector<Breakpoint>.new();
	def printer = SsaPrinter.new();
	def srcPrinter = SrcPrinter.new(prog.vst.files, interp);
	var fileMethods: Array<Vector<VstMethod>>;
	var startDel: Closure;
	var startArgs: Array<Val>;
	var running: bool;

	def invoke(del: Closure, args: Array<Val>) -> Result {
		startDel = del;
		startArgs = args;
		Terminal.put("For help, type \"help\".\n");
		var readCommand = true;
		while (readCommand) {
			var result = parser.parseCommand(parser.getCommand());
			readCommand = handleCommand(result);
		}
		return null;
	}
	def handleCommand(command: DbgCommand, args: string) -> bool {
		match (command) {
			Help => printHelp(args);
			Run => {
				start();
				execute(DbgExecuteOpt.Continue);
			}
			Continue => execute(DbgExecuteOpt.Continue);
			Step => execute(DbgExecuteOpt.Step);
			Stepi => execute(DbgExecuteOpt.Stepi);
			Next => execute(DbgExecuteOpt.Next);
			Nexti => execute(DbgExecuteOpt.Nexti);
			Finish => execute(DbgExecuteOpt.Finish);
			Info => {
				var info = parser.parseInfo(args);
				match (info) {
					Breakpoints => {
						for (i < bps.length) Terminal.put2("%d: %q\n", i, bps[i].render);
					}
					Locals => infoLocals();
					Inputs => infoInputs();
					Invalid => Terminal.put1("Invalid info args: %s\n", args);
				}
			}
			Breakpoint => {
				var result = parser.parseBreakpoint(args);
				if (result.0.length > 0 && insertBreakpoint(result)) {
					var idx = bps.length-1, ssa = bps[idx].ssa;
					Terminal.put2("Breakpoint %d %q\n", idx, ssa.source.render);
				} else Terminal.put1("Invalid breakpoint args: %s\n", args);
			}
			DisableBreakpoint => {
				handleBreakpoint(args, false);
			}
			EnableBreakpoint => {
				handleBreakpoint(args, true);
			}
			Backtrace => {
				if (running) {
					var source: Source;
					if (SsaCheckpoint.?(interp.frame.ip)) source = SsaCheckpoint.!(interp.frame.ip).source;
					var trace = interp.getStackTrace(source);
					for (list = trace; list != null; list = list.tail) {
						for (s = list.head; s != null; s = s.tail) {
							Terminal.put1("\t%q\n", s.render);
						}
					}
				}
			}
			Source => {
				var result = parser.parseSource(args);
				if (result == INVALID) Terminal.put1("Invalid source args: %s\n", args);
				else srcPrinter.outN(result);
			}
			Display => {
				var display = parser.parseDisplay(args);
				match (display) {
					Trace => interp.setTrace(true);
					Source => srcPrinter.set(true);
					CalleeSource => srcPrinter.traceCallee = true;
					Invalid => {}
				}
			}
			Undisplay => {
				var display = parser.parseDisplay(args);
				match (display) {
					Trace => interp.setTrace(false);
					Source => srcPrinter.set(false);
					CalleeSource => srcPrinter.traceCallee = false;
					Invalid => Terminal.put1("Invalid display args: %s\n", args);
				}
			}
			Unknown => {
				Terminal.put("Unknown command\n");
			}
			Quit => {
				return false;
			}
		}
		return true;
	}
	// Start the program to be debugged in the interpreter
	def start() {
		interp.reset();
		srcPrinter.reset();
		Terminal.put1("Starting program: %s\n", interp.prog.name());
		interp.pushFrame(startDel.memberRef, startDel.val, startArgs);
		running = true;
	}
	// Step debugged program and stop depending on condition
	def execute(opt: DbgExecuteOpt) {
		if (!running) start(); // ???: start or return?
		var targetSp = interp.sp;
		var prev = interp.frame.ip;
		var n = interp.step(interp.frame.ip);
		if (interp.frame == null) {
			running = false;
			printExecuteResult();
			return;
		}
		srcPrinter.putData(prev, targetSp);
		interp.frame.ip = n;
		while (!stopExecute(n, opt, targetSp)) {
			prev = interp.frame.ip;
			n = interp.step(interp.frame.ip);
			if (interp.frame == null) {
				running = false;
				break;
			}
			srcPrinter.putData(prev, targetSp);
			interp.frame.ip = n;
		}
		if (srcPrinter.on) srcPrinter.out();
		printExecuteResult();
	}
	// Decide whether to stop execution or not
	def stopExecute(instr: SsaInstr, opt: DbgExecuteOpt, targetSp: int) -> bool {
		if (isBreakpoint(instr)) return true;
		if (opt.untilBreak) return false;
		if (opt.fin) {
			if (interp.sp < targetSp) return true;
			else return false;
		} 
		if (!opt.nextLine && !opt.jump) return true; // stepi
		if (opt.jump && interp.sp > targetSp) return false; // next(i), jump over function
		if (!opt.nextLine || (opt.nextLine && SsaCheckpoint.?(instr))) return true;
		return false;
	}
	def isBreakpoint(instr: SsaInstr) -> bool {
		if (!SsaCheckpoint.?(instr)) return false;
		var checkpoint = SsaCheckpoint.!(instr);
		if (checkpoint.breakpoint) return true;
		else return false;
	}
	// Print next instruction or the final result of the debugger program
	def printExecuteResult() {
		if (interp.frame != null) {
			for (j < interp.sp-1) printer.buf.puts("  ");
			printer.buf.blue().puts("=>").end();
			printer.printInstr(interp.frame.ip, false, true, false, false);
			printer.outln();
		} else {
			var result = if (interp.exception == null, interp.retVal, interp.exception);
			var rettype = interp.prog.getMain().getReturnType();
			printer.buf.puts("Program exited: ");
			V3.renderResult(result, rettype, printer.buf);
			printer.outln();
		}
	}
	def infoLocals() {
		if (!running || !SsaCheckpoint.?(interp.frame.ip)) return;
		var nonSsaVars = interp.frame.meth.source.nonSsaVars;
		var inputs = interp.frame.ip.inputs;
		for (i < nonSsaVars.length) {
			var instr = inputs[i].dest;
			if (instr != null) {
				printer.buf.put2("%d. \"%s\": ", i, nonSsaVars[i].name());
				printer.buf.putref(instr).putc('=');
				putVal(interp.getVal(instr), nonSsaVars[i].vtype);
			}
		}
		infoVal(inputs);
	}
	def infoInputs() {
		var inputs = interp.frame.ip.inputs;
		var vtypes = if (SsaApplyOp.?(interp.frame.ip), SsaApplyOp.!(interp.frame.ip).op.typeArgs);
		for (i < inputs.length) {
			var instr = inputs[i].dest;
			if (instr != null) {
				printer.buf.put1("%d. ", i);
				printer.buf.putref(instr).putc('=');
				putVal(interp.getVal(instr), if(vtypes!=null, vtypes[i]));
			}
		}
		infoVal(inputs);
	}
	def infoVal(inputs: Array<SsaDfEdge>) {
		if (inputs.length == 0) return;
		Terminal.put("More info? (index): ");
		var result = parser.getInt();
		if (result.0 && result.1 < inputs.length) {
			var instr = inputs[result.1].dest;
			if (instr == null) {
				Terminal.put("Nothing to show\n");
				return;
			}
			var val = interp.getVal(instr);
			if (Record.?(val)) {
				var r = Record.!(val), line = r.values.length;
				if (line > PRINT_LIMIT) {
					Terminal.put1("Do you wish to see all output (%d lines)? ", line);
					if (!parser.getBool()) return;
				}
				if (V3.isClass(r.rtype)) {
					var irclass = prog.ir.getIrClass(r.rtype);
					for (i < r.values.length) {
						var field = irclass.fields[i];
						printer.buf.put1(".%q=", field.render);
						putVal(r.values[i], irclass.fields[i].fieldType);
					}
					return;
				} else if (V3.isArray(r.rtype)) {
					for (i < r.values.length) {
						printer.buf.put1("[%d]=", i);
						putVal(r.values[i], null);
					}
					return;
				}
			}
			Terminal.put("Nothing to show\n");
		}
	}
	def putVal(val: Val, vtype: Type) {
		printer.buf.puthashv(val, vtype).end();
		if (vtype != null) {
			printer.buf.putc(':').typeColor();
			vtype.render(printer.buf);
			printer.buf.end().outln();
		} else {
			printer.buf.outln();
		}
	}
	def insertBreakpoint(fileName: string, line: int) -> bool {
		for (i < prog.files.length) {
			if (Strings.equal(prog.files[i], fileName)) {
				if (line < prog.vst.files[i].lineEnds.length) {
					var vstFile = prog.vst.files[i];
					for (i < vstFile.classes.length) {
						var vstMethod = findMethod(vstFile.classes[i], line);
						if (vstMethod != null) {
							if (insertBreakpointCL(vstFile.classes[i], vstMethod, line)) return true;
							return false;
						}
					}
					for (i < vstFile.components.length) {
						var vstMethod = findMethod(vstFile.components[i], line);
						if (vstMethod != null) {
							if (insertBreakpointCL(vstFile.components[i], vstMethod, line)) return true;
							return false;
						}
					}
				}
				return false;
			}
		}
		return false;
	}
	def findMethod(vstCompound: VstCompound, line: int) -> VstMethod {
		var members = vstCompound.members;
		for (l = members; l != null; l = l.tail) {
			if (VstMethod.?(l.head) && VstMethod.!(l.head).body.range().contains(line, 0)) {
				return VstMethod.!(l.head);
			}
		}
		return null;
	}
	def insertBreakpointCL(vstCompound: VstCompound, vstMethod: VstMethod, line: int) -> bool {
		var ctype = vstCompound.getDeclaredType();
		var irClass = prog.ir.getIrClass(ctype);
		var irMethod: IrMethod;
		for (m in irClass.methods) {
			if (m != null && m.source == vstMethod) {
				irMethod = m;
				break;
			}
		}
		// Generate ssa if haven't
		if (irMethod.ssa == null) {
			var receiver = vstCompound.declType;
			var ta = if(irMethod.typeArgs != null, Arrays.prepend(receiver, irMethod.typeArgs.types), [receiver]);
			var spec = prog.ir.fromIrMemberAndTypes(ta, irMethod);
			irMethod.ssa = genSsa(spec, 0);
		}
		// Iterate ssa to find SsaCheckpoint pointing to line
		var blocks = irMethod.ssa.bfBlocks(null);
		for (b in blocks) {
			for (i = b.next; i != null && i != b; i = i.next) {
				match(i) {
					x: SsaCheckpoint => {
						if (x.source.line == line) {
							bps.put(Breakpoint.new(x));
							return true;
						}
					}
				}
			}
		}
		return false;
	}
	// Enable/Disable a breakpoint
	def handleBreakpoint(args: string, on: bool) {
		var result = Ints.parseDecimal(args, 0);
		if (args.length == 0 || result.0 != args.length) {
			Terminal.put1("Invalid breakpoint: %s\n", args);
		} else {
			var index = result.1;
			if (index < bps.length) {
				if (on) bps[index].enable();
				else bps[index].disable();
			} else Terminal.put1("Invalid breakpoint: %d\n", index);
		}
	}
	def printHelp(args: string) {
		var id: int;
		if (args.length == 0) {
			for (cmd in DbgCommand) printHelpCmd(cmd.cmdName, cmd.alias, cmd.help);
		} else if (Strings.equal(args, "info")) {
			for (cmd in DbgInfo) printHelpCmd(cmd.cmdName, cmd.alias, cmd.help);
		} else if (Strings.equal(args, "display")) {
			for (cmd in DbgDisplay) printHelpCmd(cmd.cmdName, cmd.alias, cmd.help);
		}
	}
	def printHelpCmd(cmdName: string, alias: string, help: string) {
		if (Strings.equal(cmdName, alias)) printer.buf.puts(cmdName);
		else printer.buf.put2("%s/%s", cmdName, alias);
		printer.buf.pad(' ', 16);
		printer.buf.puts(help).outln();
	}
}

def INVALID = -1;
class DebuggerParser {
	def STDIN = 0;

	def getCommand() -> string {
		var sb = StringBuilder.new();
		System.puts("(debug) ");
		var ch = byte.!(System.fileRead(STDIN));
		while (ch != '\n') {
			sb.putc(ch);
			ch = byte.!(System.fileRead(STDIN));
		}
		return sb.extract();
	}
	def parseCommand(command: string) -> (DbgCommand, /*args*/string) {
		var name: string;
		var args: string = "";
		for (i < command.length) {
			if (command[i] == ' ') {
				name = Arrays.range(command, 0, i);
				args = Arrays.range(command, i + 1, command.length);
				break;
			}
			if (i == command.length - 1) name = command;
		}
		if (name == null) return (DbgCommand.Unknown, command);
		for (cmd in DbgCommand) {
			if (Strings.equal(name, cmd.cmdName) || Strings.equal(name, cmd.alias)) {
				return (cmd, args);
			}
		}
		return (DbgCommand.Unknown, command);
	}
	def parseInfo(args: string) -> DbgInfo {
		if (args.length == 0) return DbgInfo.Invalid;
		for (e in DbgInfo) {
			if (Strings.equal(args, e.alias) || Strings.equal(args, e.cmdName)) return e;
		}
		return DbgInfo.Invalid;
	}
	def parseBreakpoint(args: string) -> (/*fileName*/string, /*line*/int) {
		if (args.length == 0) return ("", 0);
		for (i < args.length) {
			if (args[i] == ' ') {
				var fileName = Arrays.range(args, 0, i);
				if (!Strings.endsWith(fileName, ".v3")) {
					fileName = Strings.format1("%s.v3", fileName);
				}
				var result = Ints.parseDecimal(args, i+1);
				if (result.0 + i + 1 == args.length) {
					return (fileName, result.1);
				} else return ("", 0);
			}
		}
		return ("", 0);
	}
	def parseDisplay(args: string) -> DbgDisplay {
		if (args.length == 0) return DbgDisplay.Invalid;
		for (e in DbgDisplay) {
			if (Strings.equal(args, e.alias) || Strings.equal(args, e.cmdName)) return e;
		}
		return DbgDisplay.Invalid;
	}
	def parseSource(args: string) -> int {
		if (args.length == 0) return PRINT_LIMIT;
		var result = Ints.parseDecimal(args, 0);
		if (result.0 == args.length) return result.1;
		else return INVALID;
	}
	def getInt() -> (bool, int) {
		var sb = StringBuilder.new();
		var ch = byte.!(System.fileRead(STDIN));
		while (ch != '\n') {
			sb.putc(ch);
			ch = byte.!(System.fileRead(STDIN));
		}
		var input = sb.extract();
		if (input.length == 0) return (false, 0);
		var result = Ints.parseDecimal(input, 0);
		if (result.0 == input.length) return (true, result.1);
		else return (false, 0);
	}
	def getBool() -> bool {
		var sb = StringBuilder.new();
		var ch = byte.!(System.fileRead(STDIN));
		while (ch != '\n') {
			sb.putc(ch);
			ch = byte.!(System.fileRead(STDIN));
		}
		var input = sb.extract();
		if (input[0] == 'y' || input[0] == 'Y') return true;
		else return false;
	}
}
class Breakpoint {
	def ssa: SsaCheckpoint;
	new(ssa) {
		ssa.breakpoint = true;
	}
	def render(out: StringBuilder) -> StringBuilder { 
		return out.put2("%q (%z)", ssa.source.render, ssa.breakpoint);
	}
	def disable() { ssa.breakpoint = false; }
	def enable() { ssa.breakpoint = true; }
}

def storeLimit = 50;
def storeRemove = 10;
class SrcPrinter(vstFiles: Array<VstFile>, interp: SsaInterpreter) {
	def padNum = 6;
	def tmpBuf = TerminalBuffer.new();
	def outBuf = TerminalBuffer.new();
	def ends = Vector<int>.new();
	var on: bool;
	var traceCallee: bool;
	var indent: int;

	def set(on: bool) {
		this.on = on;
		if (on) reset();
	}
	def reset() {
		ends.resize(0);
		tmpBuf.reset();
		outBuf.reset();
	}
	def putData(instr: SsaInstr, targetSp: int) {
		if (!traceCallee && interp.sp != targetSp) return;
		if (SsaCheckpoint.?(instr)) {
			var source = SsaCheckpoint.!(instr).source;
			var point = FilePoint.new(null, source.line, source.column);
			extractTmpConstraint(0);
			addEnds(outBuf.length);
			tmpBuf.putd(source.line).tab().rjustify(' ', padNum, padNum);
			putNewIndent(targetSp);
			outBuf.puts(tmpBuf.extract());
			outBuf.puts(point.extractLine(vstFiles[0].input, vstFiles[0].lineEnds)).ln();
		} else if (SsaApplyOp.?(instr)) {
			putVal(instr);
		} else if (SsaReturn.?(instr)) {
			var i = interp.stack[interp.sp - 1].ip; // Caller instr
			if (!SsaApplyOp.?(i)) return;
			putVal(i);
		}
	}
	def addEnds(i: int) {
		ends.put(i);
		if (ends.length > storeLimit) {
			var newBuf = Arrays.range(outBuf.buf, ends[storeRemove], outBuf.length);
			outBuf.reset();
			outBuf.puts(newBuf);
			var newEnds = Arrays.range(ends.array, storeRemove + 1, ends.length);
			for (j < newEnds.length) newEnds[j] -= ends[storeRemove];
			Vectors.overwrite(ends, newEnds);
		}
	}
	def putVal(instr: SsaInstr) {
		var vtype = instr.getType();
		if (VoidType.?(vtype) || instr.valueNum < 0) return;
		var source = SsaApplyOp.!(instr).source;
		var point = source.column - 1;
		var pad = if(source.startColumn != -1, source.startColumn-1, point);
		extractTmpConstraint(pad);
		tmpBuf.pad(' ', pad);
		tmpBuf.pad('~', point);
		V3.renderResult(interp.getVal(instr), vtype, tmpBuf);
		tmpBuf.pad('~', source.endColumn-1);
	}
	def out() {
		extractTmpConstraint(0);
		outBuf.outt();
		ends.resize(0);
	}
	def outN(n: int) {
		if (ends.length == 0) return;
		var i = if (ends.length - n > 0, ends.length - n, 0);
		var s = Arrays.range(outBuf.buf, ends[i], outBuf.length);
		Terminal.put(s);
	}
	def putNewIndent(targetSp: int) {
		indent = 0;
		while (targetSp < interp.sp) {
			outBuf.tab();
			indent++;
			targetSp++;
		}
	}
	def putIndent() {
		for (i < indent) outBuf.tab();
	}
	def extractTmpConstraint(len: int) {
		if (tmpBuf.length >= len) {
			putIndent();
			outBuf.pad(' ', padNum).tab().valColor().puts(tmpBuf.ln().extract()).end();
		}
	}
}